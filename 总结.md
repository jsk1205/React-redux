##### redux
1>是什么?
  a.做状态管理的js库 不是react插件库
  b.可以与react配合使用,可以用在react,angular,vue等项目
  c.集中式管理(读/更新) react应用中多个组件共享的状态
2>流程
  1>>何时调用reducer:1+n(也在reducer里面初始化原始数据)
  2>>移除组件 状态,及操作状态的方法

  yarn add redux
  3>>创建store核心对象,同时指定好为store服务的reducer(本身是个函数)
  然后 redux->store.js并暴露
  import {createStore} from 'redux'
  import countReducer from './countReducer'
  let store=createStore(countReducer)
  export default store

  //-->countReducer--->Reducers加工完状态给store了
  let initStat=0
  export default function (preState=initState,action){
    const {type,data}=action
    let newState
    switch(type):
          case 'increment':
          newState= preState+data
          return newState;
          case 'decrement': newState=preState-data
          return newState;
          default : return preState//不加也不减
  }

  //-->count.jsx(组件)
  //引入store
  import store from '../../redux/store'
  当前求和为 {store.getState()}
  //<h1>当前求和为:{store.getState()}</h1>
  //通知redux加value
  store.dispatch()
  //store.dispatch(increment(value*1))

  //-->index.js  即组件和redux(说的算话的人 store)建立联系
  需要在入口js文件里面引入
  import store from './redux/store'
  //驱动页面
  getState() --:读
  dispatch() --:更新

  随之 store.subscribe()//如果redux保存的状态发生变化,那么就调用store.subscribe所指定的回调
  //原始写法
  ReactDOM.render(<App/>,document.getElementById('root'))
  store.subscribe(()=>{
    ReactDOM.render(<App/>,document.getElementById('root'))
  })
  与组件产生交互***********************************************************
  *******  即整个交互是store利用store.getState()和store.dispatch()来操作的 ******
  DOM
  App render()//重新调用render生成新的 虚拟dom,不代表整个页面都会刷新,因为dom的diff算法在那看着哪
  count render()//亦是如此

##### redux完整版
对action
//用于count组件相关的action :定义函数并暴露 type:INCREMENT,data:value
##### 对组件的分类
 1>按路由分 :一般组件
            路由组件
 2>按react-redux分:
      UI组件:
        1>>组件中不能出现任何redux相关的东西
        2>>只负责页面的展示,点击事件等
      容器组件:
        1>>是UI组件的父组件
        2>>容器组件可以随意使用redux的api
        3>>容器组件会直接跟redux打交道,随后传递状态,操作状态的方法给UI组件
 3>模型
 a.所有的UI组件都应该包裹一个容器组件,他们是父子关系
 b.容器组件是真正和redux打交道的,里面可以随意的使用redux的api
 c.UI组件中不能使用任何redux的api
 d.容器组件会传给UI组件:1>>redux中所保存的状态
                      2>>用于操作状态的方法
 e.容器与UI之间的传递:状态,操作状态的方法,均通过props传递

 ##### react-redux
 yarn add react-redux
1))容器组件 肯定是组件,不是你亲自去定义的而是靠函数生成的( count()()返回一个容器组件 )
//function mapStateToProps (state){
// 	return {count:state}
// }
以及mapDispatchToProps随之暴露

-->containers->Count.jsx //容器组件
 1>引入UI组件 
 2>引入一个方法 connnect() 
    这个方法在 react-redux 身上
    即 import {connect} from 'react-redux'
    1>>.connect()的返回值依然是一个函数
    2>>.connect()() 的返回值是一个容器组件
    3>>.connect使用的方法是:connect(状态,操作状态的方法)(UI组件)
 3>暴露 export default connect(状态,操作状态的方法)(Count即ui组件)
 4>在App.js里面渲染 containers/Count(App中渲染的不再是UI的count了)-->会报错
 5>在index.js里面引入 react-redux 
    import {Provider} from 'react-redux'
    ReactDOM.render(
    <Provider store={store}>
      <BrowserRouter>
      <App/>
      </BrowserRouter>
    </Provider>,document.getElementById('root'))
 把自己的store给了Provider	,Provider提供了  yangjiazhe
 报错就会消失,底层(react-redux)会调用
 而store.subscribe 就不需要用了
 6>不需要在容器组件里引入 store(redux的核心人物),而是在整个应用组件的最上方的顶级组件 Provider,里面包裹的app悄悄的接到一个store,而不需要我们引入是Provider在底层偷偷传过来的
 也就是说 connect()(UI组件),引入使用并调用,这时Provider就会给容器传东西

2))容器组件->UI组件:向UI组件传递
  1>mapStateToProps()用于给UI组件传递redux中的状态,以props形式传递
    1>>因为 props是key-value的形式,所以mapStateToProps方法必须返回一个object对象
    2>>mapStateToProps方法所返回的那个对象的key就作为传给UI组件props的key
    3>>mapStateToProps方法所返回的value亦是如此
  2>mapDispatchToProps()用于给UI组件传递redux中的操作状态的方法,以props形式
  3>mapStateToProps和mapDispatchToProps都是函数
  4>mapDispatchToProps可以直接是一个对象,经过connect函数的加工会包装成函数
  即
    dispatch=>(
    {
      increment:(value)=>{dispatch(increment(value))},
      decrement:(value)=>{dispatch(decrement(value))}
      }
    )
    //精简版
    {increment,decrement}
  5>connect函数底层有判断,若第二个参数是对象,会加工成一个函数

  6>交互部分***************************************************
  state=>({count:state}),//来映射状态
  //<h1>当前求和为:{this.props.count}</h1>获取数据
  然后调用方法this.props.increment(value*1)

  7>抽离出UI组件的异步
  在action中 创建 '等一等'的action
    1 >> 有一种特殊的action,是函数 之前用的是对象
    2 >> 该函数会交给store
    3 >> store底层加了判断,如果action是函数就立刻调用,且传入 store.dispatch
    4 >> 总结
      我们通常管incrementAsync 叫 异步action
      所谓的异步action是一个函数(特殊的),里面开启了一个异步任务而已
      异步action中往往都会用到同步action
      //等一等 返回值
   export const incrementAsync=(value,time)=>{
     return (dispatch)=>{
       setTimeout(()=>{
         dispatch(inrecment(value))
       },time)
     }
   } //报错提示 缺少中间架 然后还需要applyMiddleware (在redux身上)
而 const incrementAsync=(value,time)=>{
      setTimeout(()=>{
         dispatch(inrecment(value))
       },time)
   }
   incrementAsync的返回值是undefined,因为()=>{
    dispatch(inrecment(value))
  },time)返回给离他最近的函数 

  8> 支持异步action 的thunk 即中间架-->store.js
  yarn add redux-thunk 用于支持异步action
  import  {createStore,applyMiddleware} from 'redux'
  import thunk from 'redux-thunk'
  export default createStore(countReducer,applyMiddleware(thunk))
  
  9>合并多个reducer 的api 在redux身上 
  
  //index.js 而引入 汇总的人 
  import {combineReducers} from 'redux'
  //在store 引入 总的reducer 
  import allReducer from './reducers/index'
  //此时报错 Object no React child
  (我们想把一个数组展示出来,react做的遍历,但是你写的是对象(由于汇总时要传入一个对象),那react不能帮你展开这个对象,当年 在count容器里面拿状态的时候写的是 state=>({count:state})肯定就导致错误出现,所以我们需要写 state.number  [count:决定 UI ->props number->总状态])
  createStore(allReducer,applyMiddleware(thunk))
  汇总:
  combineReducers是函数
  combineReducers调用时要传入一个对象,这个对象就是redux中的总状态
  combineReducers的返回值是一个总是reducer

  10> actionType.js :定义添加 的方法-->
  action->Person.js :行为 -->(为store服务)
  reducer->person.js  引入actionType.js 来响应 add这件事
  11>小结:那 可不可以有总的操作状态的方法???
  redux:可以拿到combineReducers(汇总reducer,里面的状态是总的状态),applyMiddleware(用于执行中间架的)
  react-redux:connect方法
  redux-thunk(中间架):用来处理async 的action

###### 纯函数与高阶函数
A.纯函数:一类特别的函数,只有是同样的输入(实参),必定得到同样的输出(返回)
 约束:1>不得改写参数数据
      2>不会产生任何副作用,例如网络请求,输入和输出设备
      3>不能调用Date.now() 或Math.random()等不纯的方法
 即redux的render函数必须是一个纯函数
 newState=[data,...perState]//纯函数

 preState.unshift(data) //改写原数据--不纯了 
 newState=preState
 //但此时 控制台确实是有数据的,但是页面没展示更新的数据 因为 堆内存里面地址没发生变化
 return newState
B.高阶函数 :一类特别的函数
情况1:参数是函数
情况2:返回是函数
如下
  定时器:setTime
  数组的forEach()/map()/filter()/reduce()/find()
  函数对象的bind() :符合情况2
  Promise()/then()
  antd中的Form.create()()[3.0时代已弃用]
  react-router-dom 中的withRouter
  react-redux中的connect()
都是高阶函数
C.作用
 能够实现更加共享,更加可扩展的功能

##### 总结
redux默认是不能进行异步处理的
应用中又需要在redux中执行异步任务(ajax,定时器)




  
